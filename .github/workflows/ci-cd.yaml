# ---------------------------------------------------------------------------------------------------------------------
# CI/CD WORKFLOW
# Build, test, push to ACR, and deploy to AKS
# ---------------------------------------------------------------------------------------------------------------------
name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

env:
  ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER }}
  AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME }}
  AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP }}

jobs:
  # ---------------------------------------------------------------------------
  # BUILD AND TEST
  # ---------------------------------------------------------------------------
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ACR_LOGIN_SERVER }}/backend-api
          tags: |
            type=sha,prefix=
            type=ref,event=branch
            type=ref,event=pr

      - name: Build backend-api image (test)
        uses: docker/build-push-action@v6
        with:
          context: ./src/backend-api
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build worker image (test)
        uses: docker/build-push-action@v6
        with:
          context: ./src/worker
          push: false
          tags: ${{ env.ACR_LOGIN_SERVER }}/worker:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ---------------------------------------------------------------------------
  # PUSH TO ACR
  # ---------------------------------------------------------------------------
  push:
    name: Push to ACR
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        uses: azure/docker-login@v2
        with:
          login-server: ${{ env.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend-api
        uses: docker/build-push-action@v6
        with:
          context: ./src/backend-api
          push: true
          tags: |
            ${{ env.ACR_LOGIN_SERVER }}/backend-api:${{ github.sha }}
            ${{ env.ACR_LOGIN_SERVER }}/backend-api:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push worker
        uses: docker/build-push-action@v6
        with:
          context: ./src/worker
          push: true
          tags: |
            ${{ env.ACR_LOGIN_SERVER }}/worker:${{ github.sha }}
            ${{ env.ACR_LOGIN_SERVER }}/worker:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ---------------------------------------------------------------------------
  # DEPLOY TO DEV
  # ---------------------------------------------------------------------------
  deploy-dev:
    name: Deploy to Dev
    needs: push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
    environment: dev
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Install kubelogin
        run: |
          az aks install-cli
          kubelogin convert-kubeconfig -l spn --client-id ${{ secrets.AZURE_CLIENT_ID }} --client-secret ${{ secrets.AZURE_CLIENT_SECRET }}
        env:
          AAD_SERVICE_PRINCIPAL_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AAD_SERVICE_PRINCIPAL_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Substitute variables in manifests
        run: |
          export IMAGE_TAG=${{ github.sha }}
          export ENVIRONMENT=dev
          export INGRESS_HOST=${{ vars.INGRESS_HOST }}
          export WORKLOAD_IDENTITY_CLIENT_ID=${{ vars.WORKLOAD_IDENTITY_CLIENT_ID }}
          export KEY_VAULT_NAME=${{ vars.KEY_VAULT_NAME }}
          export AZURE_TENANT_ID=${{ vars.AZURE_TENANT_ID }}

          for file in kubernetes/*.yaml kubernetes/**/*.yaml; do
            if [ -f "$file" ]; then
              envsubst < "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
            fi
          done

      - name: Deploy to AKS
        run: |
          kubectl apply -f kubernetes/namespace.yaml
          kubectl apply -f kubernetes/configmap.yaml
          kubectl apply -f kubernetes/secret-provider-class.yaml
          kubectl apply -f kubernetes/backend-api/
          kubectl apply -f kubernetes/worker/

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/backend-api -n app --timeout=120s
          kubectl rollout status deployment/worker -n app --timeout=120s

  # ---------------------------------------------------------------------------
  # DEPLOY TO PROD (manual approval via GitHub Environment)
  # ---------------------------------------------------------------------------
  deploy-prod:
    name: Deploy to Prod
    needs: push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod')
    environment: prod
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Install kubelogin
        run: |
          az aks install-cli
          kubelogin convert-kubeconfig -l spn --client-id ${{ secrets.AZURE_CLIENT_ID }} --client-secret ${{ secrets.AZURE_CLIENT_SECRET }}
        env:
          AAD_SERVICE_PRINCIPAL_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AAD_SERVICE_PRINCIPAL_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Substitute variables in manifests
        run: |
          export IMAGE_TAG=${{ github.sha }}
          export ENVIRONMENT=prod
          export INGRESS_HOST=${{ vars.INGRESS_HOST }}
          export WORKLOAD_IDENTITY_CLIENT_ID=${{ vars.WORKLOAD_IDENTITY_CLIENT_ID }}
          export KEY_VAULT_NAME=${{ vars.KEY_VAULT_NAME }}
          export AZURE_TENANT_ID=${{ vars.AZURE_TENANT_ID }}

          for file in kubernetes/*.yaml kubernetes/**/*.yaml; do
            if [ -f "$file" ]; then
              envsubst < "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
            fi
          done

      - name: Deploy to AKS
        run: |
          kubectl apply -f kubernetes/namespace.yaml
          kubectl apply -f kubernetes/configmap.yaml
          kubectl apply -f kubernetes/secret-provider-class.yaml
          kubectl apply -f kubernetes/backend-api/
          kubectl apply -f kubernetes/worker/

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/backend-api -n app --timeout=120s
          kubectl rollout status deployment/worker -n app --timeout=120s
